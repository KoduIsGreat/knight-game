// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package player

import (
	"fmt"
)

const (
	// PlayerStateIDLE is a PlayerState of type IDLE.
	PlayerStateIDLE PlayerState = iota
	// PlayerStateRUNNING is a PlayerState of type RUNNING.
	PlayerStateRUNNING
	// PlayerStateJUMPING is a PlayerState of type JUMPING.
	PlayerStateJUMPING
	// PlayerStateFALLING is a PlayerState of type FALLING.
	PlayerStateFALLING
)

const _PlayerStateName = "IDLERUNNINGJUMPINGFALLING"

var _PlayerStateMap = map[PlayerState]string{
	PlayerStateIDLE:    _PlayerStateName[0:4],
	PlayerStateRUNNING: _PlayerStateName[4:11],
	PlayerStateJUMPING: _PlayerStateName[11:18],
	PlayerStateFALLING: _PlayerStateName[18:25],
}

// String implements the Stringer interface.
func (x PlayerState) String() string {
	if str, ok := _PlayerStateMap[x]; ok {
		return str
	}
	return fmt.Sprintf("PlayerState(%d)", x)
}

var _PlayerStateValue = map[string]PlayerState{
	_PlayerStateName[0:4]:   PlayerStateIDLE,
	_PlayerStateName[4:11]:  PlayerStateRUNNING,
	_PlayerStateName[11:18]: PlayerStateJUMPING,
	_PlayerStateName[18:25]: PlayerStateFALLING,
}

// ParsePlayerState attempts to convert a string to a PlayerState.
func ParsePlayerState(name string) (PlayerState, error) {
	if x, ok := _PlayerStateValue[name]; ok {
		return x, nil
	}
	return PlayerState(0), fmt.Errorf("%s is not a valid PlayerState", name)
}

// MarshalText implements the text marshaller method.
func (x PlayerState) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *PlayerState) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParsePlayerState(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

func PlayerStateValues() []PlayerState {
	values := make([]PlayerState, 0, len(_PlayerStateValue))
	for v := range _PlayerStateMap {
		values = append(values, v)
	}
	return values
}
